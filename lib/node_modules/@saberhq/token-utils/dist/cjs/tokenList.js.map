{"version":3,"file":"tokenList.js","sourceRoot":"","sources":["../../src/tokenList.ts"],"names":[],"mappings":";;;AAKA,yCAAmC;AAEnC;;GAEG;AACU,QAAA,aAAa,GAAG;IAC3B,SAAS;IACT,UAAU;IACV,OAAO;IACP,WAAW;IACX,SAAS;IACT,MAAM;IACN,SAAS;IACT,QAAQ;IACR,SAAS;IACT,MAAM;CACE,CAAC;AAkDX;;;;GAIG;AACI,MAAM,YAAY,GAAG,CAAC,SAAoB,EAAyB,EAAE;IAC1E,MAAM,GAAG,GAA0B,EAAE,CAAC;IACtC,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAChC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,gBAAK,CAAC,IAAI,CAAC,CAAC;IACtC,CAAC,CAAC,CAAC;IACH,OAAO,GAAG,CAAC;AACb,CAAC,CAAC;AANW,QAAA,YAAY,gBAMvB;AAEF;;;;GAIG;AACI,MAAM,YAAY,GAAG,CAAC,MAAmB,EAAe,EAAE;IAC/D,MAAM,IAAI,GAAG,IAAI,GAAG,EAAU,CAAC;IAC/B,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;QAC7B,MAAM,OAAO,GAAG,GAAG,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,OAAO,EAAE,CAAC;QACpD,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;YACrB,OAAO,KAAK,CAAC;SACd;aAAM;YACL,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAClB,OAAO,IAAI,CAAC;SACb;IACH,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAXW,QAAA,YAAY,gBAWvB","sourcesContent":["import type {\n  SPLTokenExtensions,\n  SPLTokenInfo,\n  SPLTokenList,\n} from \"./splTokenRegistry.js\";\nimport { Token } from \"./token.js\";\n\n/**\n * Known origin chains.\n */\nexport const ORIGIN_CHAINS = [\n  \"bitcoin\",\n  \"ethereum\",\n  \"terra\",\n  \"avalanche\",\n  \"binance\",\n  \"celo\",\n  \"polygon\",\n  \"fantom\",\n  \"polygon\",\n  \"heco\",\n] as const;\n\n/**\n * Known origin chains.\n */\nexport type OriginChain = typeof ORIGIN_CHAINS[number];\n\n/**\n * Token extensions with additional information.\n */\nexport type TokenExtensions = SPLTokenExtensions & {\n  /**\n   * Mints of the underlying tokens that make up this token.\n   * E.g. a Saber USDC-USDT LP token would use the USDC and USDT mints.\n   */\n  readonly underlyingTokens?: string[];\n  /**\n   * The protocol that this token comes from.\n   * E.g. `wormhole-v1`, `wormhole-v2`, `allbridge`, `sollet`, `saber`.\n   */\n  readonly source?: string;\n\n  /*\n   ** Link to the source's website where you can acquire this token\n   */\n  readonly sourceUrl?: string;\n  /**\n   * The currency code of what this token represents, e.g. BTC, ETH, USD.\n   */\n  readonly currency?: string;\n  /**\n   * If this token is a bridged token, this is the chain that the asset originates from.\n   */\n  readonly originChain?: OriginChain;\n};\n\n/**\n * Token info.\n */\nexport type TokenInfo = Omit<SPLTokenInfo, \"extensions\"> & {\n  readonly extensions?: TokenExtensions;\n};\n\n/**\n * A list of tokens, based off of the Uniswap standard.\n */\nexport type TokenList = Omit<SPLTokenList, \"tokens\"> & {\n  readonly tokens: TokenInfo[];\n};\n\n/**\n * Creates a token map from a TokenList.\n * @param tokens\n * @returns\n */\nexport const makeTokenMap = (tokenList: TokenList): Record<string, Token> => {\n  const ret: Record<string, Token> = {};\n  tokenList.tokens.forEach((item) => {\n    ret[item.address] = new Token(item);\n  });\n  return ret;\n};\n\n/**\n * Dedupes a list of tokens, picking the first instance of the token in a list.\n * @param tokens\n * @returns\n */\nexport const dedupeTokens = (tokens: TokenInfo[]): TokenInfo[] => {\n  const seen = new Set<string>();\n  return tokens.filter((token) => {\n    const tokenID = `${token.address}_${token.chainId}`;\n    if (seen.has(tokenID)) {\n      return false;\n    } else {\n      seen.add(tokenID);\n      return true;\n    }\n  });\n};\n"]}