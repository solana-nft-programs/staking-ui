import JSBI from "jsbi";
import invariant from "tiny-invariant";
import { MAX_U64, MAX_U256, Rounding, ZERO } from "./constants";
import { Big, Fraction } from "./fraction";
import { Percent } from "./percent";
import { makeDecimalMultiplier, parseBigintIsh } from "./utils";
/**
 * Parses a token amount from a decimal representation.
 * @param token
 * @param uiAmount
 * @returns
 */
export const parseAmountFromString = (token, uiAmount) => {
    const parts = uiAmount.split(".");
    if (parts.length === 0) {
        throw new Error("empty number");
    }
    invariant(parts[0]);
    const whole = JSBI.BigInt(parts[0]);
    const fraction = parts[1]
        ? JSBI.BigInt(parts[1].slice(0, token.decimals) +
            Array(token.decimals).fill("0").slice(parts[1].length).join(""))
        : JSBI.BigInt(0);
    const combined = JSBI.add(JSBI.multiply(whole, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(token.decimals))), fraction);
    return combined;
};
export class TokenAmountOverflow extends RangeError {
    constructor(type, amount) {
        super(`Token amount overflows ${type}: ${amount.toString()}`);
    }
}
export class TokenAmountUnderflow extends RangeError {
    constructor(amount) {
        super(`Token amount must be greater than zero: ${amount.toString()}`);
    }
}
/**
 * Validates that a number falls within the range of u64.
 * @param value
 */
export function validateU64(value) {
    if (!JSBI.greaterThanOrEqual(value, ZERO)) {
        throw new TokenAmountUnderflow(value);
    }
    if (!JSBI.lessThanOrEqual(value, MAX_U64)) {
        throw new TokenAmountOverflow("u64", value);
    }
}
/**
 * Validates that a number falls within the range of u256.
 * @param value
 */
export function validateU256(value) {
    if (!JSBI.greaterThanOrEqual(value, ZERO)) {
        throw new TokenAmountUnderflow(value);
    }
    if (!JSBI.lessThanOrEqual(value, MAX_U256)) {
        throw new TokenAmountOverflow("u256", value);
    }
}
const stripTrailingZeroes = (num) => {
    const [head, tail, ...rest] = num.split(".");
    if (rest.length > 0 || !head) {
        console.warn(`Invalid number passed to stripTrailingZeroes: ${num}`);
        return num;
    }
    if (!tail) {
        return num;
    }
    return `${head}.${tail.replace(/\.0+$/, "")}`;
};
export class TokenAmount extends Fraction {
    /**
     * amount _must_ be raw, i.e. in the native representation
     */
    constructor(token, amount, validate) {
        const parsedAmount = parseBigintIsh(amount);
        validate === null || validate === void 0 ? void 0 : validate(parsedAmount);
        super(parsedAmount, makeDecimalMultiplier(token.decimals));
        this.token = token;
        this.token = token;
    }
    withAmount(amount) {
        return this.new(this.token, amount);
    }
    get raw() {
        return this.numerator;
    }
    toSignificant(significantDigits = 6, format, rounding = Rounding.ROUND_DOWN) {
        return super.toSignificant(significantDigits, format, rounding);
    }
    toFixed(decimalPlaces = this.token.decimals, format, rounding = Rounding.ROUND_DOWN) {
        invariant(decimalPlaces <= this.token.decimals, "DECIMALS");
        return super.toFixed(decimalPlaces, format, rounding);
    }
    toExact(format = { groupSeparator: "" }) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        Big.DP = this.token.decimals;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access
        return new Big(this.numerator).div(this.denominator.toString()).toFormat(format);
    }
    add(other) {
        invariant(this.token.equals(other.token), `add token mismatch: ${this.token.toString()} !== ${other.token.toString()}`);
        return this.withAmount(JSBI.add(this.raw, other.raw));
    }
    subtract(other) {
        invariant(this.token.equals(other.token), `subtract token mismatch: ${this.token.toString()} !== ${other.token.toString()}`);
        return this.withAmount(JSBI.subtract(this.raw, other.raw));
    }
    /**
     * Gets this TokenAmount as a percentage of the other TokenAmount.
     * @param other
     * @returns
     */
    percentOf(other) {
        invariant(this.token.equals(other.token), `percentOf token mismatch: ${this.token.toString()} !== ${other.token.toString()}`);
        const frac = this.divide(other);
        return new Percent(frac.numerator, frac.denominator);
    }
    /**
     * Gets this TokenAmount as a percentage of the other TokenAmount.
     * @param other
     * @returns
     */
    divideBy(other) {
        const frac = this.divide(other);
        return new Percent(frac.numerator, frac.denominator);
    }
    /**
     * Multiplies this token amount by a fraction.
     * WARNING: this loses precision
     * @param percent
     * @returns
     */
    scale(fraction) {
        return this.withAmount(fraction.asFraction.multiply(this.raw).toFixed(0));
    }
    /**
     * Reduces this token amount by a percent.
     * WARNING: this loses precision
     * @param percent
     * @returns
     */
    reduceBy(percent) {
        return this.scale(Percent.ONE_HUNDRED.subtract(percent));
    }
    /**
     * Formats this number using Intl.NumberFormatOptions
     * @param param0
     * @returns
     */
    format({ numberFormatOptions, locale } = {}) {
        return `${numberFormatOptions !== undefined
            ? this.asNumber.toLocaleString(locale, numberFormatOptions)
            : stripTrailingZeroes(this.toFixed(this.token.decimals))}`;
    }
    /**
     * Gets the value of this {@link TokenAmount} as a number.
     */
    get asNumber() {
        return parseFloat(this.toExact());
    }
    /**
     * Returns true if the other object is a {@link TokenAmount}.
     *
     * @param other
     * @returns
     */
    static isTokenAmount(other) {
        return (Fraction.isFraction(other) &&
            !!(other === null || other === void 0 ? void 0 : other.token));
    }
    // ----------------------------------------------------------------
    // DEPRECATED FUNCTIONS
    // ----------------------------------------------------------------
    /**
     * Gets this TokenAmount as a percentage of the other TokenAmount.
     * @param other
     * @deprecated use {@link percentOf}
     * @returns
     */
    divideByAmount(other) {
        return this.percentOf(other);
    }
    /**
     * Multiplies this token amount by a fraction.
     * WARNING: this loses precision
     * @param percent
     * @deprecated use {@link scale}
     * @returns
     */
    multiplyBy(fraction) {
        return this.scale(fraction);
    }
}
//# sourceMappingURL=tokenAmount.js.map